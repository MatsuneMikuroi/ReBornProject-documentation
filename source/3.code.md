# Explication du code
Comme expliqué dans l'introduction, j'ai choisi de développer ce jeu avec la librairie de fichiers ```PyGame```. Ce package contient tous les outils nécessaires au développement du jeu. Il permet, entre autres, de lancer le jeu et de créer une fenêtre de jeu d'une taille donnée. Il offre aussi la possibilité de pouvoir gérer les collisions entre différentes entités et le décor ou les boîtes de dialogues. Néanmoins ```PyGame``` tout seul ne suffit pas au fonctionnement de tout, c'est pour cela que j'ai dû utiliser en parallèle le package ```pytmx``` qui permet la récolte des informations de fichiers en format ```.tmx```.

Il est pratiquement impossible (voir totalement) de créer un jeu vidéo entièrement en Python. Il devient typiquement difficile de gérer de grandes maps ou bien encore les sauvegardes du joueurs. Le premier point est grandement facilité par l'utilisation de fichier ```.tmx```. Pour le second il est possible d'utiliser des fichiers ```.json``` qui permettent de facilement stocker des informations. 

## Les fichiers principaux
Néanmoins, les fichiers permettant de faire tourner le jeux sont tous écrits en Python. Ces derniers sont au nombre de 6 et sont divisés de façon à ce que chaque fichier ne concerne qu'un seul aspect du jeu.
### main.py
Ce fichier est le fichier principal. Il est celui qui permet d'intialiser ```pygame``` et de lancer la boucle du jeu. Il ne dépend uniquement de la librairie ```pygame``` et de la classe ```Game``` présente dans le fichier ```game.py```. Ce très court fichier reste cependant primordial au bon fonctionnement du programme. Parmi les deux seules fonctions appelées la première sert à initialiser ```pygame``` tandis que la seconde joue la boucle quasi-infinie qui fait tourner le jeu, ```game``` étant une instance de la classe ```Game```.

```python
import pygame
from game import Game

if __name__ == "__main__":
    pygame.init()
    game = Game()
    game.run()

```

### game.py
Si le fichier ```main.py``` est le fichier principal, ```game.py``` et le cœur du programme. Ce dernier est composé de la classe ```Game``` qui permet au jeu son bon déroulement et son initialisation. Celle-ci est décomposée en trois méthodes distinctes qui permetttent d'initialiser le jeu, récupérer les entrées du joueur et de faire tourner le jeu avec la boucle quasi-infinie de la fonction ```run()```.

```python
from entities import *
from map import MapManager
from text import DialogBox


class Game:
    def __init__(self, screen_dimensions: tuple = (1920, 1020)):
        # create game window
        screen_dimensions = list(screen_dimensions)
        if screen_dimensions[0] < 480:
            screen_dimensions[0] = 480
        if screen_dimensions[1] < 255:
            screen_dimensions[1] = 255
        screen_dimensions = tuple(screen_dimensions)

        self.screen = pygame.display.set_mode(screen_dimensions)
        pygame.display.set_caption("Project ReBorn")

        self.zoom = screen_dimensions[0] / 480

        # generate player
        self.player = Player()

        self.map_manager = MapManager(self.screen, self.player, self.zoom)

        self.in_dialog = False

        self.dialog_box = DialogBox('dialog', screen_dimensions=screen_dimensions,
                                    width=int(200 * self.zoom), height=int(40 * self.zoom), zoom=self.zoom)

    def handle_input(self):
        pressed = pygame.key.get_pressed()
        dir_x = None
        dir_y = None
        go_up, go_down, go_left, go_right = False, False, False, False
        face = ''
        sprint = pressed[pygame.K_LSHIFT]

        handed = "right_handed"

        if handed == "right_handed":
            go_up = pygame.K_w
            go_down = pygame.K_s
            go_left = pygame.K_a
            go_right = pygame.K_d
        elif handed == "left_handed":
            go_up = pygame.K_i
            go_down = pygame.K_k
            go_left = pygame.K_j
            go_right = pygame.K_l
        if pressed[go_up] is not pressed[go_down]:
            if pressed[go_up]:
                dir_y, face = "up", "up"
            elif pressed[go_down]:
                dir_y, face = "down", "down"
        if pressed[go_left] is not pressed[go_right]:
            if pressed[go_left]:
                dir_x, face = "left", "left"
            elif pressed[go_right]:
                dir_x, face = "right", "right"
        self.player.move(face, sprint, dir_x, dir_y)

    def run(self):  # game loop
        clock = pygame.time.Clock()
        running: bool = True
        while running:
            self.player.save_location()
            if not self.in_dialog:
                self.handle_input()
            self.map_manager.update()
            self.dialog_box.render(self.screen, self.zoom)
            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        self.in_dialog = self.map_manager.check_npc_collisions(self.dialog_box)

            clock.tick(60)
        pygame.quit()

```

### map.py
Le fichier ```map.py``` gère, comme son nom l'indique, de la gestion des différentes cartes disponibles dans le jeu. Ce dernier est composé des ```dataclass``` ```Portals```, qui s'occupe de stocker les informations inhérante aux différents portails qui permettent de changer de cartes, et ```Map```, qui permet de stocker les différentes informations de ces dernières. C'est également dans ce fichier que sont stockées toutes les informations brutes des des cartes. Cela inclus leur nom, leur zone, le zoom qui leur appliqué, la liste des différents portails ainsi que celle des différent PNJs.

```python
from dataclasses import dataclass
import pytmx
import pyscroll
from entities import *


@dataclass
class Portal:
    origin_map: str
    target_map: str
    point: str


@dataclass
class Map:
    name: str
    walls: list
    group: pyscroll.PyscrollGroup
    tmx_data: pytmx.TiledMap
    portals: list
    npcs: list


class MapManager:
    def __init__(self, screen, player, zoom):
        self.maps = dict()
        self.screen = screen
        self.player = player
        self.zoom = zoom
        self.current_map = "Home_up"
        self.register_all_map()
        self.tp_player("Spawn")
        self.tp_npcs()

    def check_npc_collisions(self, dialog_box):
        for sprite in self.get_group().sprites():
            if sprite.feet.colliderect(self.player.rect) and type(sprite) is NPC:
                return dialog_box.execute(sprite.dialog)

    def check_collisions(self):
        # portals
        for portal in self.get_map().portals:
            if portal.origin_map == self.current_map:
                point = self.get_object(portal.point)
                rect = pygame.Rect(point.x, point.y, point.width, point.height)

                if self.player.feet.colliderect(rect):
                    copy_portal = portal
                    self.current_map = portal.target_map
                    self.tp_player(copy_portal.point)
        # walls/entities
        for sprite in self.get_group().sprites():
            if type(sprite) is NPC:
                if sprite.feet.colliderect(self.player.rect):
                    sprite.speed = 0
                else:
                    sprite.speed = 1.75
            
            if sprite.feet.collidelist(self.get_walls()) > -1:
                sprite.move_back()

    def tp_player(self, name: str):
        point = self.get_object(name)
        self.player.position[0] = point.x
        self.player.position[1] = point.y
        self.player.save_location()

    def register_all_map(self):
        self.register_map(
            "Around_home",
            "Beach",
            zoom=self.zoom,
            portals=[
                Portal(origin_map="Around_home", target_map="Home_down", point="Home_enter"),
                Portal(origin_map="Around_home", target_map="Atlantis", point="Atlantis_north_enter")
            ],
            npcs=[
                NPC("Beach", "Krab", nb_points=2, dialog=["BLoop bloop"])
                ],

        )

        self.register_map(
            "Home_down",
            "Beach",
            zoom=self.zoom,
            portals=[
                Portal(origin_map="Home_down", target_map="Around_home", point="Home_exit"),
                Portal(origin_map='Home_down', target_map="Home_up", point="Home_up")
            ],
        )

        self.register_map(
            "Home_up",
            "Beach",
            zoom=self.zoom,
            portals=[
                Portal(origin_map="Home_up", target_map="Home_down", point="Home_down")
            ]
        )

        self.register_map(
            "Atlantis",
            "Beach",
            zoom=self.zoom,
            portals=[
                Portal(origin_map="Atlantis", target_map="Around_home", point="Around_home_enter"),
                Portal(origin_map="Atlantis", target_map="Abandoned_house", point="Abandoned_house_enter"),
                Portal(origin_map="Atlantis", target_map="Abandoned_house", point="Easter_egg_exit")
            ],
            npcs=[
                NPC("Beach", "Blondie", nb_points=7, dialog=["J'espère que cette tempète ne sera pas \n aussi violente "
                                                             "que celle qui a ravagé \n notre cité autrefois."]),

                NPC("Beach", "Brownie", nb_points=8, dialog=["Salut, comment ça va ?", "Ça fait un moment qu'on s'est "
                                                                                       "pas vu."]),

                NPC("Beach", "Dark_Brownie", nb_points=8, dialog=["Salut, comment ça va ?", "Ma soeur te cherchait."]),

                NPC("Beach", "Gindie", nb_points=4, dialog=["Ouah, tu a l'air un peu pâle aujourd'hui."]),

                NPC("Beach", "Gumi", nb_points=4, dialog=["J'espère que la tempête ne va pas raser \n le village...",
                                                          "Je ne saurais où aller si c'était le cas."]),

                NPC("Beach", "Hatsured_Miku", nb_points=1, dialog=["Depuis deux-trois jours il me semble \n "
                                                                   "appercevoir un homme sur un tas de sable \n"
                                                                   " au Nord-ouest de l'île."
                                                                   ]),

                NPC("Beach", "Historia", nb_points=4, dialog=["C'est bizzare, cette nuit j'ai fait un \n "
                                                              "cauchemard où tout le monde se faisait \n dévorer par "
                                                              "des géants.", "Tout avait l'air si réel..."]),

                NPC("Beach", "Honey", nb_points=1, dialog=["Enfin, tu es là.", "Tu vois la tempête au loin ?",
                                                           "Cela fait déjà un moment qu'elle apparue.",
                                                           "Le problème c'est qu'elle semble de plus \n en plus "
                                                           "grande.", "J'aurais besoin que tu ailles te renseigner \n "
                                                           "au plus vite au centre météorologique de \n Mu.",
                                                           "J'espère qu'ils pourront nous aiguiller sur \n"
                                                           " ce que c'est."
                                                           ],
                    face='right'),

                NPC("Beach", "Ichigo", nb_points=1, dialog=["Le pont est acctuellement en réparation,\n "
                                                            "je te dirai quand il sera à nouveau ouvert"],
                    face='right'),

                NPC("Beach", "Jesus", nb_points=1, dialog=["Bonjour mon enfant.", "Toi aussi tu sais marcher sur"
                                                                                  " l'eau ?"]),
                NPC("Beach", "Krab", nb_points=2, dialog=["BLoop bloop"]),

                NPC("Beach", "Pumkie", nb_points=1, dialog=["C'est bizzare, depuis l'apparition de la \n tempête tous "
                                                            "les poissons semblent avoir \n disparu..."]),

                NPC("Beach", "Zone_Tan", nb_points=1, dialog=["Tout les poulpes que j'avais adoptés ont \n disparu."
                                                              "J'espère qu'ils ne se sont pas faits \n mangés."])
            ]
        )

        self.register_map(
            "Abandoned_house",
            "Beach",
            zoom=self.zoom,
            portals=[
                Portal(origin_map="Abandoned_house", target_map="Atlantis", point="Abandoned_house_exit"),
                Portal(origin_map="Abandoned_house", target_map="Atlantis", point="Easter_egg_enter")
            ]
        )

    def register_map(self, name: str, area: str, zoom: float = 4, portals: list = [], npcs: list = []):
        # load map
        tmx_data = pytmx.util_pygame.load_pygame(f"../assets/map/map_tmx/{area}/{name}.tmx")
        map_data = pyscroll.data.TiledMapData(tmx_data)
        map_layer = pyscroll.orthographic.BufferedRenderer(
            map_data, self.screen.get_size()
        )
        map_layer.zoom = zoom

        # define list of walls
        walls: list = []

        for obj in tmx_data.objects:
            if obj.name == "collision":
                walls.append(pygame.Rect(obj.x, obj.y, obj.width, obj.height))
        # draw layers group
        group = pyscroll.PyscrollGroup(map_layer=map_layer, default_layer=2)

        # add entities
        group.add(self.player)
        for npc in npcs:
            group.add(npc)
        # add map to dict
        self.maps[name] = Map(name, walls, group, tmx_data, portals, npcs)

    def get_map(self):
        return self.maps[self.current_map]

    def get_group(self):
        return self.get_map().group

    def get_walls(self):
        return self.get_map().walls

    def get_object(self, name: str):
        return self.get_map().tmx_data.get_object_by_name(name)

    def tp_npcs(self):
        for _map in self.maps:
            map_data = self.maps[_map]
            npcs = map_data.npcs

            for npc in npcs:
                npc.load_points(map_data.tmx_data)
                npc.tp_spawn()

    def draw(self):
        self.get_group().draw(self.screen)
        self.get_group().center(self.player.rect.center)

    def update(self):
        self.get_group().update()
        self.check_collisions()

        for npc in self.get_map().npcs:
            if len(npc.points) > 1:
                npc.npc_move()
            else:
                npc.static_animation(npc.face)
        self.draw()

```

### entities.py
Ce fichier sert à gérer, comme son nom l'indique, les différentes entitées. Il est premier composé de la classe ```Entity``` qui hérite de la super classe ```AnimatedSprite``` définie dans le fichier ```animation.py```. Cette denière sert principalement à définir les différentes méthodes de déplacement du joueur ainsi que les différentes informations qui permettent les déplacements. Vient ensuite la classe ```Player``` qui hérite de la classe ```Entity``` et qui sert à initialisé le personnage qu'incarne le joueur. Enfin, vient la classe ```NPC``` qui hérite également de la classe ```Entity``` et qui sert à gérer le déplacment des différents PNJs sur les cartes.
```python
import pygame
from animation import AnimateSprite


class Entity(AnimateSprite):
    def __init__(self, name: str, x: int, y: int):
        super().__init__(name)
        self.image = self.get_image(32, 0)
        self.image.set_colorkey([0, 0, 0])
        self.rect = self.image.get_rect()
        self.position = [x, y]
        self.frame = 1
        self.frame_ord = 1
        self.feet = pygame.Rect(0, 0, self.rect.width * 0.5, 12)
        self.old_position = self.position.copy()

    def save_location(self):
        self.old_position = self.position.copy()

    def move(self, face: str = '', sprint: bool = False,  direction_x: str = "", direction_y: str = ""):
        speed = self.speed + self.speed * 0.5 * int(sprint)

        if direction_y == "up":
            self.position[1] = self.position[1] - speed
        elif direction_y == "down":
            self.position[1] = self.position[1] + speed
        if direction_x == "left":
            self.position[0] = self.position[0] - speed
        elif direction_x == "right":
            self.position[0] = self.position[0] + speed
        if face != '':
            self.change_animation(face, sprint)

    def update(self):
        self.rect.topleft = self.position
        self.feet.midbottom = self.rect.midbottom

    def move_back(self):
        self.position = self.old_position
        self.rect.topleft = self.position
        self.feet.midbottom = self.rect.midbottom

    
class Player(Entity):
    def __init__(self):
        super().__init__("player", 0, 0)


class NPC(Entity):
    def __init__(self, area: str, name: str, nb_points: int, dialog: list = [''], face: str = 'down'):
        super().__init__(f"npcs/{area}/{name}", 0, 0)
        self.nb_points = nb_points
        self.dialog = dialog
        self.points = []
        self.name = name
        self.speed = 1.75
        self.current_point = 0
        self.dir_x = ""
        self.dir_y = ""
        self.face = face

    def npc_move(self):
        current_point = self.current_point
        target_point = self.current_point + 1

        if target_point >= self.nb_points:
            target_point = 0
        current_rect = self.points[current_point]
        target_rect = self.points[target_point]

        if current_rect.y < target_rect.y and abs(current_rect.x - target_rect.x) < 8:
            self.dir_x, self.dir_y, self.face = '', "down", "down"
        elif current_rect.y > target_rect.y and abs(current_rect.x - target_rect.x) < 8:
            self.dir_x, self.dir_y, self.face = '', "up", "up"
        elif current_rect.x > target_rect.x and abs(current_rect.y - target_rect.y) < 8:
            self.dir_x, self.dir_y, self.face = "left", '', "left"
        elif current_rect.x < target_rect.x and abs(current_rect.y - target_rect.y) < 8:
            self.dir_x, self.dir_y, self.face = "right", '', "right"
        self.move(direction_x=self.dir_x, direction_y=self.dir_y)
        self.change_animation(self.face)

        if self.rect.colliderect(target_rect):
            self.current_point = target_point

    def tp_spawn(self):
        location = self.points[self.current_point]
        self.position[0] = location.x
        self.position[1] = location.y
        self.save_location()

    def load_points(self, tmx_data):
        for num in range(1, self.nb_points + 1):
            point = tmx_data.get_object_by_name(f"{self.name}_path{num}")
            rect = pygame.Rect(point.x, point.y, point.width, point.height)
            self.points.append(rect)

```

### animation.py
Ce fichier n'est composé que d'une seule classe: ```AnimatedSprite```. Cette dernière est, comme expliqué précédemment, la classe parente de la classe ```Entity```. Elle hérite d'ailleurs de la classe ```pygame.sprite.Sprite``` qui est de base implémentée dans PyGame. Cette classe permet la gestion des différentes animations des personnages, joueur comme non-joueurs, essentiellement lors de leurs mouvements. C'est également elle qui s'occupe de la récupération des images des personnages.
```python
import pygame


class AnimateSprite(pygame.sprite.Sprite):
    def __init__(self, name):
        super().__init__()
        self.sprite_sheet = pygame.image.load(f"../assets/chara/{name}.png")
        self.animation_index = 1
        self.ord = 1
        self.clock = 0
        self.images = {
            "down": self.get_images(0),
            "left": self.get_images(32),
            "right": self.get_images(64),
            "up": self.get_images(96)
            }
        self.speed = 2.5
        
    def change_animation(self, direction: str = '', sprint: bool = False):
        self.speed = self.speed + self.speed * 2 * int(sprint)
        self.image = self.images[direction][self.animation_index]
        self.image.set_colorkey([0, 0, 0])
        self.clock = self.clock + self.speed * 8

        if self.clock >= 100:
            self.animation_index = self.animation_index + (1 * self.ord)

            if self.animation_index >= len(self.images[direction]):
                self.ord = -1
                self.animation_index = self.animation_index - 1

            elif self.animation_index == 0:
                self.ord = 1
                
            self.clock = 0

    def static_animation(self, direction: str = ''):
        self.image = self.images[direction][self.animation_index]
        self.image.set_colorkey([0, 0, 0])

    def get_images(self, y):
        images = []
        
        for i in range(0, 3):
            x = i * 32
            images.append(self.get_image(x, y))
            
        return images
    
    def get_image(self, x, y):
        image = pygame.Surface([32, 32])
        image.blit(self.sprite_sheet, (0, 0), (x, y, 32, 32))
        return image
```

### text.py
Ce fichier est celui dont la fonction est, je dirai, la moins primordiale. Il est constitué uniquement de la classe ```DialogBox``` et permet de gérer les différentes boîtes de dialogues. Hors, un jeu vidéo reste un jeu vidéo même sans dialogue entre les personnages alors qu'il est difficile d'en imaginer un sans carte ou bien sans personnage à l'écran. Néanmoins le dialogue est bien souvent une composante essentielle. Il sert, aider de la musique et des effets sonores, à transmettre l'histoire. Même si il est possible d'y parvenir sans, comme les excellents _Limbo_ et _Inside_ du studio _Playdead_. N'ayant pas leurs capacités, j'ai fait le choix raisonnable de faire parler les différents PNJs, mais en aucun cas le joueur.
```python
import pygame


class DialogBox:
    def __init__(self, name: str, screen_dimensions: tuple = (1920, 1020),
                 width: int = 700, height: int = 100, zoom: float = 4, font: str = 'default'):
        self.box = pygame.image.load(f'../assets/texts/boxes/{name}.png')
        self.x_pos: int = (screen_dimensions[0]-width) / 2
        self.y_pos: int = (screen_dimensions[1]-height) - 10 * zoom
        self.msg = []
        self.msg_index = 0
        self.lines = []
        self.box = pygame.transform.scale(self.box, (width, height))
        self.font = pygame.font.Font(f'../assets/texts/fonts/{font}.ttf', int(7 * zoom))
        self.open = False
        
    def execute(self, dialog: list):
        if self.open:
            self.next_text()
        else:
            self.open = True
            self.msg_index = 0
            self.msg = dialog

        return self.open
        
    def render(self, screen, zoom: float = 4):
        self.y_inc = 5
        if self.open:
            screen.blit(self.box, (self.x_pos, self.y_pos))
            self.lines = self.msg[self.msg_index].split('\n ')
            for line in range(len(self.lines)):
                text = self.font.render(self.lines[line], False, (0, 0, 0))
                screen.blit(text, (self.x_pos + zoom, self.y_pos + int(self.y_inc * zoom)))
                # Locate the text for the new line.
                self.y_inc = self.y_inc + 10
            
    def next_text(self):
        self.msg_index = self.msg_index + 1
        
        if self.msg_index >= len(self.msg):
            self.open = False

```


## Les différentes classes et méthodes complexes

### Game
Comme expliqué précédemment, la classe ```Game``` permet la création d'une nouvelle instance de jeu.

- La première méthode est donc celle d'initialisation. Cette dernière ne prend qu'un tuple comme paramètre qui détermine les dimensions qu'aura la fenêtre de jeu. Néanmoins, le programme va effectuer une vérification afin d'être sûr que les dimensions permettent malgré tout d'avoir un jeu jouable. Une fois, cette vérification effectuée la fenêtre de jeu est créée ainsi que nommer et le jeu est redimensionné si besoin. Vient ensuite l'initialisation de l'instance du joueur générée depuis la classe ```Player``` issue du fichier ```entities.py```. Chose faite, le jeu charge la map et les informations sur les boîtes de dialogue. Ces deux instances se réfèrent respectivement à la classe MapManager du fichier ```map.py``` et ```DialogBox``` de ```text.py```.

```python
    def __init__(self, screen_dimensions: tuple = (1920, 1020)):
        # create game window
        screen_dimensions = list(screen_dimensions)
        if screen_dimensions[0] < 480:
            screen_dimensions[0] = 480
        if screen_dimensions[1] < 255:
            screen_dimensions[1] = 255
        screen_dimensions = tuple(screen_dimensions)

        self.screen = pygame.display.set_mode(screen_dimensions)
        pygame.display.set_caption("Project ReBorn")

        self.zoom = screen_dimensions[0] / 480

        # generate player
        self.player = Player()

        self.map_manager = MapManager(self.screen, self.player, self.zoom)

        self.in_dialog = False

        self.dialog_box = DialogBox('dialog', screen_dimensions=screen_dimensions,
                                    width=int(200 * self.zoom), height=int(40 * self.zoom), zoom=self.zoom)
```

- La seconde permet de récupérer les inputs du joueur pour savoir quand ce dernier se déplace. Une fois les informations récupérées (direction(s) du déplacement et vitesse (sprint ou non)) le joueur est déplacé et le sprint change son orientation.

```python
    def handle_input(self, handed = "right_handed"):
        pressed = pygame.key.get_pressed()
        dir_x = None
        dir_y = None
        go_up, go_down, go_left, go_right = False, False, False, False
        face = ''
        sprint = pressed[pygame.K_LSHIFT]

        if handed == "right_handed":
            go_up = pygame.K_w
            go_down = pygame.K_s
            go_left = pygame.K_a
            go_right = pygame.K_d
        elif handed == "left_handed":
            go_up = pygame.K_i
            go_down = pygame.K_k
            go_left = pygame.K_j
            go_right = pygame.K_l
        if pressed[go_up] is not pressed[go_down]:
            if pressed[go_up]:
                dir_y, face = "up", "up"
            elif pressed[go_down]:
                dir_y, face = "down", "down"
        if pressed[go_left] is not pressed[go_right]:
            if pressed[go_left]:
                dir_x, face = "left", "left"
            elif pressed[go_right]:
                dir_x, face = "right", "right"
        self.player.move(face, sprint, dir_x, dir_y)
```
- Enfin, la méthode ```run()``` est la dernière de la classe et celle qui va jouer la boucle infinie de jeu tout en vérifiant les différents événements (rafraîchissement de la map, changement de map, dialogue avec les PNJs[^pnj] ou fermeture de la fenêtre de jeu).

```python
    def run(self):  # game loop
        clock = pygame.time.Clock()
        running: bool = True
        while running:
            self.player.save_location()
            if not self.in_dialog:
                self.handle_input()
            self.map_manager.update()
            self.dialog_box.render(self.screen, self.zoom)
            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        self.in_dialog = self.map_manager.check_npc_collisions(self.dialog_box)

            clock.tick(60)
        pygame.quit()
```

### MapManager
Comme expliqué plus haut, la classe ```MapManager``` permet la gestion des différentes cartes du jeu. Cela commence avec les méthodes ```check_npc_collisions``` et ```check_collisions``` qui viennt vérifier les différentes collisions que le joueur et entités vont avoir entre eux et l'environement. Dans le cas de la première, cela permet au joueur d'intéragir avec les PNJs alors que la deuxième vient stopper le joueur lorsque ce dernier fonce dans une bordure ou un PNJ lorque ce dernier fonce dans le joueur.
```python
    def check_npc_collisions(self, dialog_box):
        for sprite in self.get_group().sprites():
            if sprite.feet.colliderect(self.player.rect) and type(sprite) is NPC:
                return dialog_box.execute(sprite.dialog)

    def check_collisions(self):
        # portals
        for portal in self.get_map().portals:
            if portal.origin_map == self.current_map:
                point = self.get_object(portal.point)
                rect = pygame.Rect(point.x, point.y, point.width, point.height)

                if self.player.feet.colliderect(rect):
                    copy_portal = portal
                    self.current_map = portal.target_map
                    self.tp_player(copy_portal.point)
        # walls/entities
        for sprite in self.get_group().sprites():
            if type(sprite) is NPC:
                if sprite.feet.colliderect(self.player.rect):
                    sprite.speed = 0
                else:
                    sprite.speed = 1.75
            
            if sprite.feet.collidelist(self.get_walls()) > -1:
                sprite.move_back()
```

Vient ensuite la méthode ```tp_player``` qui permet de faire changer de zone au joueur.
```python
    def tp_player(self, name: str):
        point = self.get_object(name)
        self.player.position[0] = point.x
        self.player.position[1] = point.y
        self.player.save_location()

```

Viennent après les deux méthodes qui permettent d'enregistrer toutes les cartes avec les informations concernant les PNJs, les collisions, les différents portails avec leur destination, etc. Ce sont les méthodes ```register_map``` et ```register_all_map```. 
```python
    def register_all_map(self):
        self.register_map(
            "Around_home",
            "Beach",
            zoom=self.zoom,
            portals=[
                Portal(origin_map="Around_home", target_map="Home_down", point="Home_enter"),
                Portal(origin_map="Around_home", target_map="Atlantis", point="Atlantis_north_enter")
            ],
            npcs=[
                NPC("Beach", "Krab", nb_points=2, dialog=["BLoop bloop"])
                ],

        )

        self.register_map(
            "Home_down",
            "Beach",
            zoom=self.zoom,
            portals=[
                Portal(origin_map="Home_down", target_map="Around_home", point="Home_exit"),
                Portal(origin_map='Home_down', target_map="Home_up", point="Home_up")
            ],
        )

        self.register_map(
            "Home_up",
            "Beach",
            zoom=self.zoom,
            portals=[
                Portal(origin_map="Home_up", target_map="Home_down", point="Home_down")
            ]
        )

        self.register_map(
            "Atlantis",
            "Beach",
            zoom=self.zoom,
            portals=[
                Portal(origin_map="Atlantis", target_map="Around_home", point="Around_home_enter"),
                Portal(origin_map="Atlantis", target_map="Abandoned_house", point="Abandoned_house_enter"),
                Portal(origin_map="Atlantis", target_map="Abandoned_house", point="Easter_egg_exit")
            ],
            npcs=[
                NPC("Beach", "Blondie", nb_points=7, dialog=["J'espère que cette tempète ne sera pas \n aussi violente "
                                                             "que celle qui a ravagé \n notre cité autrefois."]),

                NPC("Beach", "Brownie", nb_points=8, dialog=["Salut, comment ça va ?", "Ça fait un moment qu'on s'est "
                                                                                       "pas vu."]),

                NPC("Beach", "Dark_Brownie", nb_points=8, dialog=["Salut, comment ça va ?", "Ma soeur te cherchait."]),

                NPC("Beach", "Gindie", nb_points=4, dialog=["Ouah, tu a l'air un peu pâle aujourd'hui."]),

                NPC("Beach", "Gumi", nb_points=4, dialog=["J'espère que la tempête ne va pas raser \n le village...",
                                                          "Je ne saurais où aller si c'était le cas."]),

                NPC("Beach", "Hatsured_Miku", nb_points=1, dialog=["Depuis deux-trois jours il me semble \n "
                                                                   "appercevoir un homme sur un tas de sable \n"
                                                                   " au Nord-ouest de l'île."
                                                                   ]),

                NPC("Beach", "Historia", nb_points=4, dialog=["C'est bizzare, cette nuit j'ai fait un \n "
                                                              "cauchemard où tout le monde se faisait \n dévorer par "
                                                              "des géants.", "Tout avait l'air si réel..."]),

                NPC("Beach", "Honey", nb_points=1, dialog=["Enfin, tu es là.", "Tu vois la tempête au loin ?",
                                                           "Cela fait déjà un moment qu'elle apparue.",
                                                           "Le problème c'est qu'elle semble de plus \n en plus "
                                                           "grande.", "J'aurais besoin que tu ailles te renseigner \n "
                                                           "au plus vite au centre météorologique de \n Mu.",
                                                           "J'espère qu'ils pourront nous aiguiller sur \n"
                                                           " ce que c'est."
                                                           ],
                    face='right'),

                NPC("Beach", "Ichigo", nb_points=1, dialog=["Le pont est acctuellement en réparation,\n "
                                                            "je te dirai quand il sera à nouveau ouvert"],
                    face='right'),

                NPC("Beach", "Jesus", nb_points=1, dialog=["Bonjour mon enfant.", "Toi aussi tu sais marcher sur"
                                                                                  " l'eau ?"]),
                NPC("Beach", "Krab", nb_points=2, dialog=["BLoop bloop"]),

                NPC("Beach", "Pumkie", nb_points=1, dialog=["C'est bizzare, depuis l'apparition de la \n tempête tous "
                                                            "les poissons semblent avoir \n disparu..."]),

                NPC("Beach", "Zone_Tan", nb_points=1, dialog=["Tout les poulpes que j'avais adoptés ont \n disparu."
                                                              "J'espère qu'ils ne se sont pas faits \n mangés."])
            ]
        )

        self.register_map(
            "Abandoned_house",
            "Beach",
            zoom=self.zoom,
            portals=[
                Portal(origin_map="Abandoned_house", target_map="Atlantis", point="Abandoned_house_exit"),
                Portal(origin_map="Abandoned_house", target_map="Atlantis", point="Easter_egg_enter")
            ]
        )

    def register_map(self, name: str, area: str, zoom: float = 4, portals: list = [], npcs: list = []):
        # load map
        tmx_data = pytmx.util_pygame.load_pygame(f"../assets/map/map_tmx/{area}/{name}.tmx")
        map_data = pyscroll.data.TiledMapData(tmx_data)
        map_layer = pyscroll.orthographic.BufferedRenderer(
            map_data, self.screen.get_size()
        )
        map_layer.zoom = zoom

        # define list of walls
        walls: list = []

        for obj in tmx_data.objects:
            if obj.name == "collision":
                walls.append(pygame.Rect(obj.x, obj.y, obj.width, obj.height))
        # draw layers group
        group = pyscroll.PyscrollGroup(map_layer=map_layer, default_layer=2)

        # add entities
        group.add(self.player)
        for npc in npcs:
            group.add(npc)
        # add map to dict
        self.maps[name] = Map(name, walls, group, tmx_data, portals, npcs)

```

Enfin, arrive toute une panoplie de méthodes qui servent à récupérer les différentes informations des fichiers ```.tmx``` ainsi qu'à dessiner la carte et à la mettre à jour.

### AnimateSprite
Cette classe, composée de quatre méthodes en plus de celle d'initialisation, est là uniquement pour permettre l'animation ou la non-animation des différents personnages lors de leurs mouvements. La première, ```change_animation```, vient changer la partie de la planche d'image[^sheet] du personnage afin de passer à l'image suivante ou à la précédante ou bien encore de changer d'orientation.
```python
    def change_animation(self, direction: str = '', sprint: bool = False):
        self.speed = self.speed + self.speed * 2 * int(sprint)
        self.image = self.images[direction][self.animation_index]
        self.image.set_colorkey([0, 0, 0])
        self.clock = self.clock + self.speed * 8

        if self.clock >= 100:
            self.animation_index = self.animation_index + (1 * self.ord)

            if self.animation_index >= len(self.images[direction]):
                self.ord = -1
                self.animation_index = self.animation_index - 1

            elif self.animation_index == 0:
                self.ord = 1
                
            self.clock = 0
```
Les deux suivantes permettent de récupérer la bonne planche d'image pour le personnage et la seconde vient récupérer la bonne image de l'animation de déplacement.
```python
    def get_images(self, y):
        images = []
        
        for i in range(0, 3):
            x = i * 32
            images.append(self.get_image(x, y))
            
        return images
    
    def get_image(self, x, y):
        image = pygame.Surface([32, 32])
        image.blit(self.sprite_sheet, (0, 0), (x, y, 32, 32))
        return image
```
Finalement, la dernière n'est là uniquement pour éviter que les personnages statiques n'aient quand-même une animation de déplacement.
```python
    def static_animation(self, direction: str = ''):
        self.image = self.images[direction][self.animation_index]
        self.image.set_colorkey([0, 0, 0])
```
### Entity et NPC
Les classes ```Entity``` et ```NPC``` ont un fonctionnement très similaire, la seule différence est que la première est plus orienté pour les déplacements et la gestion du joueur alors que la seconde l'est plus pour la gestion des PNJs incluant leur mouvement ainsi que leurs différentes propriétés supplémentaire, comme les dialogues.
```python
class Entity(AnimateSprite):
    def __init__(self, name: str, x: int, y: int):
        super().__init__(name)
        self.image = self.get_image(32, 0)
        self.image.set_colorkey([0, 0, 0])
        self.rect = self.image.get_rect()
        self.position = [x, y]
        self.frame = 1
        self.frame_ord = 1
        self.feet = pygame.Rect(0, 0, self.rect.width * 0.5, 12)
        self.old_position = self.position.copy()

    def save_location(self):
        self.old_position = self.position.copy()

    def move(self, face: str = '', sprint: bool = False,  direction_x: str = "", direction_y: str = ""):
        speed = self.speed + self.speed * 0.5 * int(sprint)

        if direction_y == "up":
            self.position[1] = self.position[1] - speed
        elif direction_y == "down":
            self.position[1] = self.position[1] + speed
        if direction_x == "left":
            self.position[0] = self.position[0] - speed
        elif direction_x == "right":
            self.position[0] = self.position[0] + speed
        if face != '':
            self.change_animation(face, sprint)

    def update(self):
        self.rect.topleft = self.position
        self.feet.midbottom = self.rect.midbottom

    def move_back(self):
        self.position = self.old_position
        self.rect.topleft = self.position
        self.feet.midbottom = self.rect.midbottom

class NPC(Entity):
    def __init__(self, area: str, name: str, nb_points: int, dialog: list = [''], face: str = 'down'):
        super().__init__(f"npcs/{area}/{name}", 0, 0)
        self.nb_points = nb_points
        self.dialog = dialog
        self.points = []
        self.name = name
        self.speed = 1.75
        self.current_point = 0
        self.dir_x = ""
        self.dir_y = ""
        self.face = face

    def npc_move(self):
        current_point = self.current_point
        target_point = self.current_point + 1

        if target_point >= self.nb_points:
            target_point = 0
        current_rect = self.points[current_point]
        target_rect = self.points[target_point]

        if current_rect.y < target_rect.y and abs(current_rect.x - target_rect.x) < 8:
            self.dir_x, self.dir_y, self.face = '', "down", "down"
        elif current_rect.y > target_rect.y and abs(current_rect.x - target_rect.x) < 8:
            self.dir_x, self.dir_y, self.face = '', "up", "up"
        elif current_rect.x > target_rect.x and abs(current_rect.y - target_rect.y) < 8:
            self.dir_x, self.dir_y, self.face = "left", '', "left"
        elif current_rect.x < target_rect.x and abs(current_rect.y - target_rect.y) < 8:
            self.dir_x, self.dir_y, self.face = "right", '', "right"
        self.move(direction_x=self.dir_x, direction_y=self.dir_y)
        self.change_animation(self.face)

        if self.rect.colliderect(target_rect):
            self.current_point = target_point

    def tp_spawn(self):
        location = self.points[self.current_point]
        self.position[0] = location.x
        self.position[1] = location.y
        self.save_location()

    def load_points(self, tmx_data):
        for num in range(1, self.nb_points + 1):
            point = tmx_data.get_object_by_name(f"{self.name}_path{num}")
            rect = pygame.Rect(point.x, point.y, point.width, point.height)
            self.points.append(rect)
```

### DialogBox
Cette classe vient, lorsqu'une instance est générée, afficher une boîte de dialogue au milieu en bas de l'écran dans laquelle est écrit le texte en police "Retro Gaming". Ce dernier peut être affiché sur plusieurs lignes mais la séparation d'une phrase en plusieurs lignes n'est actuellement pas automatisée et fonctionne grâce à un ```split``` de la chaine de caractères. La méthode ```render``` s'occupe de l'affichage, ```execute``` de vérifier si la boîte de dialogue est ouverte et ```next_text``` d'afficher la prochaine partie du texte ou de fermer la boîte de dialogue lorsque toutes les phrases ont été affichées.
```python
    def execute(self, dialog: list):
        if self.open:
            self.next_text()
        else:
            self.open = True
            self.msg_index = 0
            self.msg = dialog

        return self.open
        
    def render(self, screen, zoom: float = 4):
        self.y_inc = 5
        if self.open:
            screen.blit(self.box, (self.x_pos, self.y_pos))
            self.lines = self.msg[self.msg_index].split('\n ')
            for line in range(len(self.lines)):
                text = self.font.render(self.lines[line], False, (0, 0, 0))
                screen.blit(text, (self.x_pos + zoom, self.y_pos + int(self.y_inc * zoom)))
                # Locate the text for the new line.
                self.y_inc = self.y_inc + 10
            
    def next_text(self):
        self.msg_index = self.msg_index + 1
        
        if self.msg_index >= len(self.msg):
            self.open = False

```

[^pnj]: PNJ est l'acronyme de "Personnage Non Joueur", ce dernier désigne avant tout l'entièreté les entités qui vont venir interagir avec le joueur et qui sont, dans la méta du jeu, doués de conscience.
[^sheet]: Chaque planche d'image est constitué de douze images arrangées en quatre lignes de trois colonnes. La première ligne représente le déplacment vers le bas (lorsque le personnage est face à la caméra), la seconde le déplacement vers la gauche, puis la troisième celui vers la droite et enfin la dernière le déplacement vers le haut (lorsque le personnage est dos à la caméra).

## Les différents problèmes rencontrés
Lors de l'élaboration de ce projet, je me suis retrouvé confronté à plusieurs problèmes qui peuvent, selon moi, partiellement nuire à l'expérience de jeu du joueur. L'un d'eux étant la latence qu'il y a entre le rafraichissement de la carte et le joueur qui est visible lorsque la caméra bouge avec le joueur. Je pensais initialement que cela était dû au nombre d'éléments présents sur la carte, hors des cartes de tailles d'ordres différents (plus de dix fois plus grande ou plus petite) semblent avoir la même latence à l'oeil humain, cela doit donc être dû à autre chose que je n'ai pu trouver pour l'instant. Cette latence est également visible lors des changements de cartes. Vient ensuite le déplacement des PNJs qui ne peuvent se déplacer que verticalement ou horizontalement, cela est uniquement dû à la façon dont leur déplacement sont programmés. Enfin, comme expliqué précédemment, les textes dans les boîtes de dialogues doivent être renvoyer à la ligne manuellement car il n'y a pas d'espace d'affichage défini pour le texte.