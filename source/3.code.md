# Explication du code
Comme expliqué dans l'introduction, j'ai choisi de développer ce jeu avec la librairie de fichiers _PyGame_. Ce package contient tous les outils nécessaires au développement du jeu. Il permet, entre autres, de "run" le jeu et de créer une fenêtre de jeu d'une taille donné. Il offre aussi la possibilité de pouvoir gérer les collisions entre différentes entités et le décor ou les boîtes de dialogues. Néanmoins _PyGame_ tout seul ne suffit pas au fonctionnement de tout, c'est pour cela que j'ai dû utiliser en parallèle le package _pytmx_ qui permet la récolte des informations de fichiers en format _.tmx_.

Il est pratiquement impossible (voir totalement) de créer un jeu vidéo entièrement en python. Il devient typiquement difficile de gérer de grandes maps ou bien encore les sauvegardes du joueurs. Le premier point est grandement facilité par l'utilisation de fichier _.tmx_. Pour le second il est possible d'utiliser des fichiers _.json_ qui permettent de facilement stocker des informations. 

## Les fichiers principaux
Néanmoins, les fichiers permettant de faire tourner le jeux sont tous écrits en python. Ces derniers sont au nombre de 7 et sont divisés de façon à ce que chaque fichier ne concerne qu'un seul aspect du jeu.
### main.py
Ce fichier est le fichier mère. Il est celui qui permet d'intialiser _pygame_ et de lancer la boucle du jeu. Il ne dépend uniquement de la librairie _pygame_ et de la classe _Game_ présente de le fichier _game.py_. Ce très court fichier reste cependant primordial au bon fonctionnement du programme. Parmi les deux seules fonctions appelées la première sert à initialiser _pygame_ tandis que la seconde joue la boucle quasi-infini qui fait tourner le jeu, _game_ étant une instance de la classe _Game_.

```python
import pygame
from game import Game

if __name__ == "__main__":
    pygame.init()
    game = Game()
    game.run()

```

### game.py
Si le fichier _main.py_ est le fichier mère, _game.py_ et le coeur du programme. Ce dernier est composé la classe _Game_ qui va permettre au jeu son bon déroulement et son initialisation. Celle-ci est décomposée en trois fonctions distinctes qui permetttent d'initialisées le jeu, récupérées les input du joueur et de faire tourner le jeu avec la boucle quasi-infini de la fonction _run()_.

```python
from entities import *
from map import MapManager
from text import DialogBox


class Game:
    def __init__(self, screen_dimensions: tuple = (1920, 1020)):
        # create game window
        screen_dimensions = list(screen_dimensions)
        if screen_dimensions[0] < 480:
            screen_dimensions[0] = 480
        if screen_dimensions[1] < 255:
            screen_dimensions[1] = 255
        screen_dimensions = tuple(screen_dimensions)

        self.screen = pygame.display.set_mode(screen_dimensions)
        pygame.display.set_caption("Project ReBorn")

        self.zoom = screen_dimensions[0] / 480

        # generate player
        self.player = Player()

        self.map_manager = MapManager(self.screen, self.player, self.zoom)

        self.in_dialog = False

        self.dialog_box = DialogBox('dialog', screen_dimensions=screen_dimensions,
                                    width=int(200 * self.zoom), height=int(40 * self.zoom), zoom=self.zoom)

    def handle_input(self):
        pressed = pygame.key.get_pressed()
        dir_x = None
        dir_y = None
        go_up, go_down, go_left, go_right = False, False, False, False
        face = ''
        sprint = pressed[pygame.K_LSHIFT]

        handed = "right_handed"

        if handed == "right_handed":
            go_up = pygame.K_w
            go_down = pygame.K_s
            go_left = pygame.K_a
            go_right = pygame.K_d
        elif handed == "left_handed":
            go_up = pygame.K_i
            go_down = pygame.K_k
            go_left = pygame.K_j
            go_right = pygame.K_l
        if pressed[go_up] is not pressed[go_down]:
            if pressed[go_up]:
                dir_y, face = "up", "up"
            elif pressed[go_down]:
                dir_y, face = "down", "down"
        if pressed[go_left] is not pressed[go_right]:
            if pressed[go_left]:
                dir_x, face = "left", "left"
            elif pressed[go_right]:
                dir_x, face = "right", "right"
        self.player.move(face, sprint, dir_x, dir_y)

    def run(self):  # game loop
        clock = pygame.time.Clock()
        running: bool = True
        while running:
            self.player.save_location()
            if not self.in_dialog:
                self.handle_input()
            self.map_manager.update()
            self.dialog_box.render(self.screen, self.zoom)
            pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        self.in_dialog = self.map_manager.check_npc_collisions(self.dialog_box)

            clock.tick(60)
        pygame.quit()

```

### map.py

### entities.py

### animation.py

### text.py

### extractor.py


## Les différentes classes

### Game
Comme expliqué précédemment, la classe _Game_ permet la création d'une nouvelle instance de jeu.
- La première fonction est donc celle d'initialisation. Cette dernière ne prend qu'un tuple comme paramètre qui détermine les dimmensions qu'aura la fenêtre de jeu. Néanmoins le programme va effectuer une vérification afin d'être sûr que les dimmensions permettent malgré tout d'avoir un jeu jouable. Une fois cette vérification effectué la fenêtre de jeu est créée ainsi que nommée et le jeu est redimensionné si besoin. Vient ensuite l'initialisation de l'instance du joueur générée depuis la classe _Player_ issue du fichier _entities.py_. Chose faite, le jeu charge la map et les information sur les boîtes de dialogue. Ces deux instances se réfèrent respectivement à la classe MapManager du fichier _map.py_ et _DialogBox_ de _text.py_.

```python
    def __init__(self, screen_dimensions: tuple = (1920, 1020)):
        # create game window
        screen_dimensions = list(screen_dimensions)
        if screen_dimensions[0] < 480:
            screen_dimensions[0] = 480
        if screen_dimensions[1] < 255:
            screen_dimensions[1] = 255
        screen_dimensions = tuple(screen_dimensions)

        self.screen = pygame.display.set_mode(screen_dimensions)
        pygame.display.set_caption("Project ReBorn")

        self.zoom = screen_dimensions[0] / 480

        # generate player
        self.player = Player()

        self.map_manager = MapManager(self.screen, self.player, self.zoom)

        self.in_dialog = False

        self.dialog_box = DialogBox('dialog', screen_dimensions=screen_dimensions,
                                    width=int(200 * self.zoom), height=int(40 * self.zoom), zoom=self.zoom)
```

- La seconde permet de récupérer les inputs du joueur pour savoir quand ce dernier se déplace. 

```python
    def handle_input(self, handed = "right_handed"):
        pressed = pygame.key.get_pressed()
        dir_x = None
        dir_y = None
        go_up, go_down, go_left, go_right = False, False, False, False
        face = ''
        sprint = pressed[pygame.K_LSHIFT]

        if handed == "right_handed":
            go_up = pygame.K_w
            go_down = pygame.K_s
            go_left = pygame.K_a
            go_right = pygame.K_d
        elif handed == "left_handed":
            go_up = pygame.K_i
            go_down = pygame.K_k
            go_left = pygame.K_j
            go_right = pygame.K_l
        if pressed[go_up] is not pressed[go_down]:
            if pressed[go_up]:
                dir_y, face = "up", "up"
            elif pressed[go_down]:
                dir_y, face = "down", "down"
        if pressed[go_left] is not pressed[go_right]:
            if pressed[go_left]:
                dir_x, face = "left", "left"
            elif pressed[go_right]:
                dir_x, face = "right", "right"
        self.player.move(face, sprint, dir_x, dir_y)
```

### MapManager

### AnimateSprite

### Entity

#### Player

#### NPC

### DialogBox
